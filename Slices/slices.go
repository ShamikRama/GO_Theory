// slice - динамические массивы 
slice := make([]int, 0, 5) // 0 - длина, 5 - емкость(capacity)
// Так же как и все в golang представлены в виде структуры
type slice struct {
	array unsafe.Pointer // указатель на базовый массив(на первый элемент)
	len   int // длина слайса 
	cap   int // его емкость (память которую выделили под слайс)
 }

// Также можно проиницилизировать слайс вот так :

var slice []int

slice := []int{}

// В обоих случаях в слайсе ничего нет, но если мы будем делать проверку на nil, первый слайс
// выведет true второй false, поэтому надо проверять на пустоту вот так slice == 0 

list := []int{1,2,3,4,5}
var slice []int
for _, val := range list{
	slice = append(slice, val * 2)
}
// Так делать нельзя потому что мы каждый раз пересоздаем массив и аллоцируем память
// Можно сразу аллоцировать память вот так 
slice := make([]int, 0, len(list))

// Если мы изменяем какой-то элемент слайса в функции при этом не увеличивая емкость, то у нас 
// меняется сам базовый(первоначальный) слайс, но если мы увеличиваем, то у нас перевыделяется память
// и создается новый слайс не изменяя базовый(первоначальный)

// Если мы не хотим менять базовый слайс то надо использовать функцию copy
// Пример

func handle(list []int){
	newlist:=make([]int, len(list))
	copy(newlist, list)
	newlist = append(newlist, 5)
}

// СОВЕТ: Результат функции append всегда надо присваивать одному и тому же слайсу
list = append(list,4)


